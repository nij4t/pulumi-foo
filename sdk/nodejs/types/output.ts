// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface BuiltinRoleAssignmentRole {
    global?: boolean;
    uid: string;
}

export interface DashboardPermissionPermission {
    permission: string;
    role?: string;
    teamId?: number;
    userId?: number;
}

export interface DataSourceJsonData {
    assumeRoleArn?: string;
    authType?: string;
    authenticationType?: string;
    clientEmail?: string;
    connMaxLifetime?: number;
    customMetricsNamespaces?: string;
    defaultProject?: string;
    defaultRegion?: string;
    encrypt?: string;
    esVersion?: string;
    graphiteVersion?: string;
    httpMethod?: string;
    interval?: string;
    logLevelField?: string;
    logMessageField?: string;
    maxConcurrentShardRequests?: number;
    maxIdleConns?: number;
    maxOpenConns?: number;
    postgresVersion?: number;
    profile?: string;
    queryTimeout?: string;
    sigv4AssumeRoleArn?: string;
    sigv4Auth?: boolean;
    sigv4AuthType?: string;
    sigv4ExternalId?: string;
    sigv4Profile?: string;
    sigv4Region?: string;
    sslMode?: string;
    timeField?: string;
    timeInterval?: string;
    timescaledb?: boolean;
    tlsAuth?: boolean;
    tlsAuthWithCaCert?: boolean;
    tlsSkipVerify?: boolean;
    tokenUri?: string;
    tsdbResolution?: string;
    tsdbVersion?: string;
}

export interface DataSourcePermissionPermission {
    permission: string;
    teamId?: number;
    userId?: number;
}

export interface DataSourceSecureJsonData {
    accessKey?: string;
    basicAuthPassword?: string;
    password?: string;
    privateKey?: string;
    secretKey?: string;
    sigv4AccessKey?: string;
    sigv4SecretKey?: string;
    tlsCaCert?: string;
    tlsClientCert?: string;
    tlsClientKey?: string;
}

export interface FolderPermissionPermission {
    permission: string;
    role?: string;
    teamId?: number;
    userId?: number;
}

export interface PlaylistItem {
    id: string;
    order: number;
    title: string;
    type?: string;
    value?: string;
}

export interface RolePermission {
    action: string;
    scope?: string;
}

export interface SynteticMonitoringCheckSettings {
    dns?: outputs.SynteticMonitoringCheckSettingsDns;
    http?: outputs.SynteticMonitoringCheckSettingsHttp;
    ping?: outputs.SynteticMonitoringCheckSettingsPing;
    tcp?: outputs.SynteticMonitoringCheckSettingsTcp;
}

export interface SynteticMonitoringCheckSettingsDns {
    ipVersion?: string;
    port?: number;
    protocol?: string;
    recordType?: string;
    server?: string;
    sourceIpAddress?: string;
    validRCodes?: string[];
    validateAdditionalRrs?: outputs.SynteticMonitoringCheckSettingsDnsValidateAdditionalRr[];
    validateAnswerRrs?: outputs.SynteticMonitoringCheckSettingsDnsValidateAnswerRrs;
    validateAuthorityRrs?: outputs.SynteticMonitoringCheckSettingsDnsValidateAuthorityRrs;
}

export interface SynteticMonitoringCheckSettingsDnsValidateAdditionalRr {
    failIfMatchesRegexps?: string[];
    failIfNotMatchesRegexps?: string[];
}

export interface SynteticMonitoringCheckSettingsDnsValidateAnswerRrs {
    failIfMatchesRegexps?: string[];
    failIfNotMatchesRegexps?: string[];
}

export interface SynteticMonitoringCheckSettingsDnsValidateAuthorityRrs {
    failIfMatchesRegexps?: string[];
    failIfNotMatchesRegexps?: string[];
}

export interface SynteticMonitoringCheckSettingsHttp {
    basicAuth?: outputs.SynteticMonitoringCheckSettingsHttpBasicAuth;
    bearerToken?: string;
    body?: string;
    cacheBustingQueryParamName?: string;
    failIfBodyMatchesRegexps?: string[];
    failIfBodyNotMatchesRegexps?: string[];
    failIfHeaderMatchesRegexps?: outputs.SynteticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp[];
    failIfHeaderNotMatchesRegexps?: outputs.SynteticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp[];
    failIfNotSsl?: boolean;
    failIfSsl?: boolean;
    headers?: string[];
    ipVersion?: string;
    method?: string;
    noFollowRedirects?: boolean;
    proxyUrl?: string;
    tlsConfig?: outputs.SynteticMonitoringCheckSettingsHttpTlsConfig;
    validHttpVersions?: string[];
    validStatusCodes?: number[];
}

export interface SynteticMonitoringCheckSettingsHttpBasicAuth {
    password: string;
    username: string;
}

export interface SynteticMonitoringCheckSettingsHttpFailIfHeaderMatchesRegexp {
    allowMissing?: boolean;
    header: string;
    regexp: string;
}

export interface SynteticMonitoringCheckSettingsHttpFailIfHeaderNotMatchesRegexp {
    allowMissing?: boolean;
    header: string;
    regexp: string;
}

export interface SynteticMonitoringCheckSettingsHttpTlsConfig {
    caCert?: string;
    clientCert?: string;
    clientKey?: string;
    insecureSkipVerify?: boolean;
    serverName?: string;
}

export interface SynteticMonitoringCheckSettingsPing {
    dontFragment?: boolean;
    ipVersion?: string;
    payloadSize?: number;
    sourceIpAddress?: string;
}

export interface SynteticMonitoringCheckSettingsTcp {
    ipVersion?: string;
    queryResponses?: outputs.SynteticMonitoringCheckSettingsTcpQueryResponse[];
    sourceIpAddress?: string;
    tls?: boolean;
    tlsConfig?: outputs.SynteticMonitoringCheckSettingsTcpTlsConfig;
}

export interface SynteticMonitoringCheckSettingsTcpQueryResponse {
    expect: string;
    send: string;
    startTls?: boolean;
}

export interface SynteticMonitoringCheckSettingsTcpTlsConfig {
    caCert?: string;
    clientCert?: string;
    clientKey?: string;
    insecureSkipVerify?: boolean;
    serverName?: string;
}

